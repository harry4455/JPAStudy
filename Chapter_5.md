# Chapter 5. 연관관계 매핑 기초

엔티티들은 대부분 다른 엔티티와 연관관계를 가짐.
객체는 참조(주소)를 사용하여 관계를 맺고, 테이블은 외래 키를 사용해서 관계를 맺음. -> 완전히 다른 특징

객체 관계 매핑 (ORM)에서 가장 어려운 부분이 "객체 연관관계와 테이블 연관관계를 매핑" 하는 것

* 방향(direction) : [단방향, 양방향]이 존재. 방향 관계는 객체 관계에만 존재하고, 테이블 관계는 항상 양방향
* 다중성(multiplicity) : [다대일, 일대다, 일대일, 다대다] 
* 연관관계의 주인(owner) : 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 함.

## 5.1 단방향 연관관계

<p align="center">
<img src="./imgs/JPA 연관관계 매핑.png" />
</p>

* 객체 연관관계 
  - 회원 객체는 Member.team 필드로 팀 객체와 연관관계를 맺음
  - 회원 객체와 팀 객체는 단방향 관계. 회원은 Member.team 필드를 통해 팀을 알 수 있지만, 팀은 그렇지 못함 
* 테이블 연관관계 
  - 회원 테이블은 TEAM_ID 외래 키로 팀 테이블과 연관관계를 맺음
  - 회원 테이블과 팀 테이블은 양방향 관계. 외래 키를 통해서 회원과 팀 / 팀과 회원을 조인할 수 있음  
  
<br>

<b>※ 객체 연관관계와 테이블 연관관계의 가장 큰 차이점</b>  
참조를 통한 연관관계를 단방향이기에, 반대의 관계를 갖긴 위해선 필드를 추가해서 참조를 보관해야함
서로 참조하는 양방향 관계처럼 보이지만, 사실상 서로 다른 단방향 관계 2개임.


### 5.1.1 순수한 객체 연관관계

객체는 참조를 사용해서 연관관계를 탐색할 수 있음 -> 객체 그래프 탐색

### 5.1.2 테이블 연관관계

데이터베이스는 외래 키를 사용해서 연관관계를 탐색할 수 있음 -> 조인(JOIN)

### 5.1.3 객체 관계 매핑

JPA를 사용하여 객체만 사용한 연관관계와 테이블만 사용한 연관관계를 매핑

@ManyToOne : 다대일 관계라는 매핑 정보. 연관관계를 매핑할 때 다중성을 나타내는 어노테이션을 피루소 사용해야 함.  
@JoinColumn(name="") : 조인 컬럼은 외래 키를 매핑할 때 사용. name 속성에는 매핑할 외래 키 이름을 지정.해당 어노테이션은 생략 가능

### 5.1.4 @JoinColumn

외래 키를 매핑할 때 사용

|속성|기능|기본값|
|:---|:---|:---|
|name|매핑할 외래 키 이름|빌드 + _ + 참조하는 테이블의 기본 키 컬럼명|
|referencedColumnName|외래 키가 참조하는 대상 테이블의 컬럼명|참조하는 테이블의 기본 키 컬럼명|
|foreignKey(DDL)|외래 키 제약조건을 직접 지정할 수 있음. 이 속성은 테이블을 생성할때만 사용||
|unique<br> nullable<br> insertable<br> updatable<br> columnDeifinition<br> table|@Column의 속성과 같음||

### 5.1.5 @ManyToOne

다대일 관계에서 사용

|속성|기능|기본값|
|:---|:---|:---|
|optional|false로 설정하면 연관된 엔티티가 항상 있어야 함.|true|
|fetch|글로벌 패치 전략을 설정|*@ManyToOne = FetchType.EAGER <br> *@OneToMany = FetchType.LAZY|
|cascade|영속성 전이 기능을 사용||
|targetEntity|연관된 엔티티의 타입 정보를 설정. 거의 사용하지 않는 기능. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있음.||

## 5.2 연관관계 사용

### 5.2.1 저장

값들을 set하고 em.persist() 통해서 DB에 저장

### 5.2.2. 조회

조회 방법은 크게 2가지
1. 객체 그래프 탐색(객체 연관관계를 사용한 조회)
ex) member.getTeam()을 사용해서 member와 연관된 team 엔티티를 조회할 수 있음
 
2. 객체지향 쿼리 사용 (JPQL)
ex) 팀1에 소속된 회원만 조회하려는 경우 -> join절을 활용
t.name =: teamName -> :로 시작되는 것은 파라미터를 바인딩받는 문법

### 5.2.3 수정

em.update()와 같은 메소드는 없다
단순히 불러온 엔티티의 값을 변경해두면 트랜잭션을 커밋할 때 플러시가 일어나면서 변경 감지 기능이 작동함.
이후 변경사항을 DB에 자동으로 반영. 연관관계를 수정할 때에도 동일.

### 5.2.4 연관관계 제거

em.find() 이후 null 처리로 제거.
SQL로 치면 null로 UPDATE

### 5.2.5 연관된 엔티티 삭제 

연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야함.
아니면 외래 키 제약조건으로 DB에서 오류가 발생.

## 5.3 양방향 연관관계

<p align="center">
<img src="./imgs/양방향 연관관계.png" />
</p>

DB 테이블은 외래 키 하나로 양방향 조회가 가능 (양쪽을 JOIN 가능)

### 5.3.1 양방향 연관관계 매핑

팀과 회원은 일대다 관계  
따라서 팀 엔티티에 컬렉션인 List<Member> members를 추가함.
또한, 일대다 관계를 매핑하기 위해 @OneToMany 매핑 정보를 사용함.
mappedBy 속성은 양방향 매핑일 때 사용하는데, 반대쪽 매핑의 필드 이름을 값으로 주면 됨.

한쪽에선 @ManyToOne 다른 한쪽에서는 @OneToMany로 매핑함

### 5.3.2 일대다 컬렉션 조회

em.find() -> team.getMembers -> List<Member> members -> getUsername

## 5.4 연관관계의 주인

객체에는 양방향 연관관계라는 것이 없고, 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할뿐.  
반면 데이터베이스 테이블은 외래 키 하나로 양쪽이 서로 조인 가능하기에 양방향 연관관계 맺기 가능.

엔티티를 단방향으로 매핑하면 참조를 하나만 사용하므로, 해당 참조로 외래 키를 관리하면 됨.  
<b>엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래키는 하나이기에, 둘 사이에 차이가 발생  
두 객체 연관관계 중 하나를 정해 테이블의 외래키를 관리해야 하는게 이를 "연관관계의 주인(Owner)"라고 함.</b>

### 5.4.1 양방향 매핑의 규칙 : 연관관계의 주인

객체의 두 연관관계 중 하나를 연관관계의 주인으로 정해야 함.
연관관계의 주인만이 DB 연관관계와 매핑되고 외래 키를 관리(ex. CRUD) 할 수 있음. 반면에 아닌쪽은 읽기만 가능함.  

* 주인은 mappedBy 속성을 사용하지 않음.
* 주인이 아니면 mappedBy 속성을 사용해 속성의 값으로 연관관계의 주인을 지정해야 함.

<p align="center">
<img src="./imgs/연관관계의 주인.png" />
</p>

<b>연관관계의 주인을 정한다는 것은 외래 키 관리자를 선택한다는 것.</b>

### 5.4.2 연관관계의 주인은 외래 키가 있는 곳

연관관계의 주인은 테이블에 외래 키가 있는 곳으로 지정해야함.

ex) 회원 테이블이 외래 키를 가짐으로 Member.team이 주인  
    주인이 아닌 Team.members에는 mapperBy="team" 속성을 사용해 주인이 아님을 설정  
    (mappedBy 속성의 값으로는 연관관계의 주인인 team으로 설정 -> Member.team 필드를 의미)
    
"연관관계의 주인만 DB 연관관계와 매핑되고 외래 키를 관리할 수 있다"     
-> 주인이 아닌 반대편은 읽기만 가능하고, 외래키 변경이 불가함.

## 5.5 양방향 연관관계 저장

주인만이 외래 키를 관리하므로, 주인이 아니라면 값을 설정하지 않아도 DB에 외래 키 값이 정상 입력됨.

ex) Member의 team 필드로 연관관계가 지정되었음으로 (주인)  
    -> team1.getMembers().add(member1) [무시]
    -> member1.setTeam(team1) [연관관계 설정]

## 5.6 양방향 연관관계의 주의점

흔히 하는 실수로, 연관관계의 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것.

### 5.6.1 순수한 객체까지 고려한 양방향 연관관계

"사실은 객체 관점에서 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전"  
-> JPA가 아니라면 순수한 객체 상태에서는 심각한 문제가 발생할 수도 있음.

### 5.6.2 연관관계 편의 메소드

양방향 관계의 호출, 두 개의 코드는 하나인 것처럼 사용하는 것이 안전함.

ex) 리팩토링을 통해 setTeam 메소드에 team.getMembers().add()도 함께 정의  

### 5.6.3 연관관계 편의 메소드 작성 시 주의사항

member1.setTeam(team~)를 하나씩 호출할 때, 팀 변경시 기존 팀과의 삭제 코드를 추가해야함.

ex) if(this.team != null) this.team.getMembers().remove(this);

기존 팀과의 관계가 제거되지 않아도 DB 외래키를 변경하는 데에는 문제가 없다. 하지만 영속성 컨텍스트가 아직 살아있는 상태에서 호출한다면 이전의 관계가 호출되기에 제거하는 것이 안전하다

## 5.7 정리

양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐

* 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료
* 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가
* 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 함

++ 연관관계의 주인은 외래 키의 위치와 관련해서 정해야지 비즈니스 중요도로 접근하면 안됨